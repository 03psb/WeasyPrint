# coding: utf8
r"""
    weasyprint.pdf
    --------------

    Post-process the PDF files created by cairo and add metadata such as
    hyperlinks and bookmarks.


    Rather than trying to parse any valid PDF, we make some assumptions
    that hold for cairo in order to simplify the code:

    * All newlines are '\n', not '\r' or '\r\n'
    * Except for number 0 (which is always free) there is no "free" object.
    * Most white space separators are made of a single 0x20 space.
    * Indirect dictionary objects do not contain '>>' at the start of a line
      except to mark the end of the object, followed by 'endobj'.
      (In other words, '>>' markers for sub-dictionaries are indented.)
    * The Page Tree is flat: all kids of the root page node are page objects,
      not page tree nodes.

    However the code uses a lot of assert statements so that if an assumptions
    is not true anymore, the code should (hopefully) fail with an exception
    rather than silently behave incorrectly.


    :copyright: Copyright 2011-2012 Simon Sapin and contributors, see AUTHORS.
    :license: BSD, see LICENSE for details.

"""

from __future__ import division, unicode_literals
import os
import re
import itertools

from .compat import xrange


TRAILER_RE = re.compile(b'\ntrailer\n(.+)\nstartxref\n(\d+)\n%%EOF\n$',
                        re.DOTALL)
DICT_TYPE_RE = re.compile(b'/Type /(\w+)')  # + default to greedy


class PDFDictionary(object):
    def __init__(self, object_number, byte_string):
        self.object_number = object_number
        self.byte_string = byte_string

    @classmethod
    def from_file(cls, pdf_file, object_number):
        fileobj = pdf_file.fileobj
        fileobj.seek(pdf_file.object_offsets[object_number])
        line = next(fileobj)
        assert line.endswith(b' 0 obj\n')
        assert int(line[:-7]) == object_number  # len(b' 0 obj\n') == 7
        object_lines = []
        for line in fileobj:
            object_lines.append(line)
            if line == b'>>\n':
                assert next(fileobj) == b'endobj\n'
                return cls(object_number, b''.join(object_lines))

    def __repr__(self):
        return self.__class__.__name__ + repr(
            (self.object_number, self.byte_string))

    def get_type(self):
        return DICT_TYPE_RE.search(self.byte_string).group(1).decode('ascii')

    def get_indirect_object_number(self, key, __cache={}):
        """
        :return: (int) the object number
        """
        regex = __cache.get(key)
        if not regex:
            regex = re.compile(('/%s (\d+) 0 R' % key).encode('ascii'))
            __cache[key] = regex
        return int(regex.search(self.byte_string).group(1))

    def get_indirect_dict(self, key, pdf_file):
        """
        :return: a new PDFDictionary instance
        """
        return self.from_file(
            pdf_file, self.get_indirect_object_number(key))

    def get_array(self, key, __cache={}):
        """
        :return: (bytes) the unparsed array content
        """
        regex = __cache.get(key)
        if not regex:
            regex = re.compile(('/%s \[([^\]]+)\]' % key).encode('ascii'))
            __cache[key] = regex
        return regex.search(self.byte_string).group(1)

    def get_indirect_dict_array(self, key, pdf_file):
        """
        :return: a list of new PDFDictionary instance
        """
        parts = self.get_array(key).split(b' 0 R ')
        trail = parts.pop()
        assert not trail.strip()
        return [self.from_file(pdf_file, int(n)) for n in parts]


class PDFFile(object):
    """
    :param fileobj:
        A seekable binary file-like object for a PDF generated by cairo.
    """
    def __init__(self, fileobj):
        # cairoâ€™s trailer + startxref + EOF is typically under 100 bytes
        fileobj.seek(-200, os.SEEK_END)
        trailer, startxref = TRAILER_RE.search(fileobj.read()).groups()
        trailer = PDFDictionary(None, trailer)

        fileobj.seek(int(startxref))
        line = next(fileobj)
        assert line == b'xref\n'

        line = next(fileobj)
        first_object, total_objects = line.split()
        assert first_object == b'0'
        total_objects = int(total_objects)

        line = next(fileobj)
        assert line == b'0000000000 65535 f \n'

        object_offsets = [None]
        for object_number in xrange(1, total_objects):
            line = next(fileobj)
            assert line[10:] == b' 00000 n \n'
            object_offsets.append(int(line[:10]))

        self.fileobj = fileobj
        #: Maps object number -> bytes from the start of the file
        self.object_offsets = object_offsets

        info = trailer.get_indirect_dict('Info', self)
        catalog = trailer.get_indirect_dict('Root', self)
        page_tree = catalog.get_indirect_dict('Pages', self)
        pages = page_tree.get_indirect_dict_array('Kids', self)
        # Check that the tree is flat
        assert all(p.get_type() == 'Page' for p in pages)

        self.startxref = startxref
        self.trailer = trailer
        self.info = info
        self.catalog = catalog
        self.page_tree = page_tree
        self.pages = pages


def test():
    import cairo
    import io
    fileobj = io.BytesIO()
    surface = cairo.PDFSurface(fileobj, 100, 100)
    for i in xrange(20):
        surface.show_page()
    surface.finish()

    pdf = PDFFile(fileobj)
    print(pdf.page_tree)
    print(len(pdf.pages))


if __name__ == '__main__':
    test()
